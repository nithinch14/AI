from typing import Tuple, List, Set

def get_successors(state: Tuple[Tuple[int, int], List[List[int]]]) -> List[Tuple[Tuple[int, int], List[List[int]]]]:
    """
    Generate successor states from the current state.

    Rules (typical variant):
    - Move to any adjacent cell (up, down, left, right) within bounds.
    - When you move to a cell, you clean it (set to 0).
    - You may choose to toggle dirt in the visited cell as an optional extension (here we just clean).

    Feel free to modify this function to reflect your exact problem rules.
    """
    (x, y), grid = state
    successors: List[Tuple[Tuple[int, int], List[List[int]]]] = []

    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    n = len(grid)
    m = len(grid[0]) if n > 0 else 0

    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if 0 <= nx < n and 0 <= ny < m:
            # Copy grid
            new_grid = [row[:] for row in grid]
            # Cleaning action: clean the new cell you moved to
            new_grid[nx][ny] = 0
            successors.append(((nx, ny), new_grid))

    return successors

def grid_to_tuple(grid: List[List[int]]) -> Tuple[Tuple[int, ...], ...]:
    return tuple(tuple(row) for row in grid)

def is_goal(grid: List[List[int]]) -> bool:
    return all(cell == 0 for row in grid for cell in row)

def depth_first_search(state: Tuple[Tuple[int, int], List[List[int]]], visited: Set[Tuple[Tuple[int, int], Tuple[Tuple[int, ...], ...]]]) -> bool:
    """
    Depth-first search to determine if we can clean all cells.

    - state: ((x, y), grid)
    - visited: set of visited states, stored as ((x, y), grid_as_tuple)
    Returns True if a goal state is reachable, False otherwise.
    """
    (x, y), grid = state

    if is_goal(grid):
        return True

    # Use a hashable representation for visited
    grid_key = (x, y), grid_to_tuple(grid)
    if grid_key in visited:
        return False
    visited.add(grid_key)

    for succ in get_successors(state):
        if depth_first_search(succ, visited):
            return True

    return False

if _name_ == '_main_':
    # Example initial grid and position
    grid = [
        [0, 1, 1, 1],
        [0, 0, 1, 0],
        [1, 0, 0, 1],
        [1, 1, 1, 0]
    ]
    initial_position = (0, 0)
    initial_state = (initial_position, grid)

    if depth_first_search(initial_state, set()):
        print("All cells can be cleaned (goal reachable) with DFS.")
    else:
        print("Goal not reachable with the given rules.")

OUTPUT:
All cells can be cleaned (goal reachable) with DFS.
