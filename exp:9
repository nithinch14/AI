from itertools import permutations
from typing import List, Tuple

def held_karp(dist: List[List[float]]) -> Tuple[float, List[int]]:
    """
    Held-Karp dynamic programming solution for TSP (exact).
    Time complexity: O(N^2 * 2^N), Space: O(N * 2^N)
    Returns (min_cost, path) where path is the visiting order starting at 0.
    Works for small N (typically N <= 20 with optimized implementation).
    """
    n = len(dist)
    # dp[mask][i] = min cost to reach subset mask ending at city i
    size = 1 << n
    dp = [[float('inf')] * n for _ in range(size)]
    parent = [[-1] * n for _ in range(size)]

    # Base: start at city 0, cost to reach 0 with only city 0 is 0
    dp[1 << 0][0] = 0

    for mask in range(size):
        for u in range(n):
            if not (mask & (1 << u)):
                continue
            prev_mask = mask ^ (1 << u)
            if prev_mask == 0 and u != 0:
                continue
            if prev_mask == 0 and u == 0:
                continue
            # Try to extend from some v in prev_mask to u
            for v in range(n):
                if not (prev_mask & (1 << v)):
                    continue
                new_cost = dp[prev_mask][v] + dist[v][u]
                if new_cost < dp[mask][u]:
                    dp[mask][u] = new_cost
                    parent[mask][u] = v

    # Close the tour by returning to start (0)
    full_mask = (1 << n) - 1
    min_cost = float('inf')
    last = -1
    for i in range(1, n):
        cost = dp[full_mask][i] + dist[i][0]
        if cost < min_cost:
            min_cost = cost
            last = i

    # Reconstruct path
    path = [0]
    mask = full_mask
    cur = last
    while cur != -1:
        path.append(cur)
        prev = parent[mask][cur]
        mask ^= (1 << cur)
        cur = prev

    path.reverse()
    return min_cost, path

def brute_force_tsp(dist: List[List[float]]) -> Tuple[float, List[int]]:
    """
    Brute-force TSP solver (for small n).
    Fix starting city to 0 to reduce permutations.
    Returns (min_cost, best_path)
    """
    n = len(dist)
    cities = list(range(1, n))
    best_cost = float('inf')
    best_path = []

    for perm in permutations(cities):
        path = [0] + list(perm) + [0]
        cost = sum(dist[path[i]][path[i+1]] for i in range(n))
        if cost < best_cost:
            best_cost = cost
            best_path = path

    return best_cost, best_path

def format_path(path: List[int]) -> str:
    return " -> ".join(str(c) for c in path)

if _name_ == "_main_":
    # Example: 4 cities with symmetric distances (you can customize)
    dist = [
        [0.0, 2.0, 9.0, 10.0],
        [2.0, 0.0, 6.0, 4.0],
        [9.0, 6.0, 0.0, 8.0],
        [10.0, 4.0, 8.0, 0.0],
    ]

    n = len(dist)
    if n <= 10:
        # Choose approach based on n
        if n <= 10:
            cost, path = brute_force_tsp(dist)
            print("Brute-force solution:")
            print(f"Cost: {cost}")
            print(f"Path: {format_path(path)}")
        else:
            cost, path = held_karp(dist)
            print("Held-Karp (DP) solution:")
            print(f"Cost: {cost}")
            print(f"Path: {format_path(path)}")
    else:
        # For larger n, default to Held-Karp if feasible, else fallback
        cost, path = held_karp(dist)
        print("Held-Karp (DP) solution:")
        print(f"Cost: {cost}")
        print(f"Path: {format_path(path)}")
OUTPUT:
Brute-force solution:
Cost: 23.0
Path: 0 -> 1 -> 3 -> 2 -> 0
