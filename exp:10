from _future_ import annotations  

from typing import List, Tuple, Optional, Dict  
import heapq  

Coordinate = Tuple[int, int]  
Grid = List[List[int]]  # 0: free, 1: obstacle  

def heuristic(a: Coordinate, b: Coordinate) -> int:  
    """Manhattan distance heuristic for 4-directional movement."""  
    return abs(a[0] - b[0]) + abs(a[1] - b[1])  

def get_neighbors(pos: Coordinate, grid: Grid) -> List[Coordinate]:  
    """Return valid neighboring cells (up, down, left, right)."""  
    x, y = pos  
    neighbors = []  
    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]  
    n, m = len(grid), len(grid[0]) if grid else 0  
    for dx, dy in dirs:  
        nx, ny = x + dx, y + dy  
        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0:  
            neighbors.append((nx, ny))  
    return neighbors  

def a_star(grid: Grid, start: Coordinate, goal: Coordinate) -> Tuple[Optional[List[Coordinate]], Optional[int]]:  
    """  
    A* search to find the shortest path from start to goal on a grid.  

    Returns:  
        - path: list of coordinates from start to goal (including both), or None if no path  
        - cost: total cost of the path (number of steps), or None if no path  
    """  
    if grid[start[0]][start[1]] != 0 or grid[goal[0]][goal[1]] != 0:  
        return None, None  # start or goal is blocked  

    open_heap: List[Tuple[int, int, Coordinate]] = []  # (f = g + h, g, position)  
    heapq.heappush(open_heap, (heuristic(start, goal), 0, start))  

    came_from: Dict[Coordinate, Optional[Coordinate]] = {start: None}  
    g_score: Dict[Coordinate, int] = {start: 0}  
    closed: set = set()  

    while open_heap:  
        f, g, current = heapq.heappop(open_heap)  

        if current == goal:  
            # Reconstruct path  
            path: List[Coordinate] = []  
            cur = current  
            while cur is not None:  
                path.append(cur)  
                cur = came_from[cur]  
            path.reverse()  
            return path, g  

        if current in closed:  
            continue  
        closed.add(current)  

        for nb in get_neighbors(current, grid):  
            tentative_g = g + 1  # each move costs 1  
            if nb in g_score and tentative_g >= g_score[nb]:  
                continue  
            came_from[nb] = current  
            g_score[nb] = tentative_g  
            f_score = tentative_g + heuristic(nb, goal)  
            heapq.heappush(open_heap, (f_score, tentative_g, nb))  

    return None, None  # no path found  

def print_grid_with_path(grid: Grid, path: Optional[List[Coordinate]]) -> None:  
    """Utility to visualize the grid and the path."""  
    if path is None:  
        print("No path found.")  
        return  
    path_set = set(path)  
    for i, row in enumerate(grid):  
        line = ""  
        for j, cell in enumerate(row):  
            if (i, j) in path_set:  
                line += "â€¢ "  # path  
            elif cell == 0:  
                line += ". "  
            else:  
                line += "# "  
        print(line)  
    print()  
if _name_ == "_main_":  
    # Example grid:  
    # 0 = free, 1 = obstacle  
    grid = [  
        [0, 0, 0, 0, 0],  
        [0, 1, 1, 1, 0],  
        [0, 0, 0, 1, 0]
OUTPUT:
